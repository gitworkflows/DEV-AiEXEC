---
description: "Guidelines for backend development in Aiexec, focusing on Python components, FastAPI services, and backend testing."
globs:
  - "api/**/*.py"
  - "tests/**/*.py"
  - "Makefile"
  - "pyproject.toml"
  - "uv.lock"
alwaysApply: false
---


# Backend Development Guidelines

## Purpose
Guidelines for backend development in Aiexec, focusing on Python components, FastAPI services, and backend testing.

---

## 1. Backend Environment Setup

### Prerequisites
- **Python Package Manager:** `uv` (>=0.4) for dependency management
- **Database:** SQLite for development, PostgreSQL for production
- **Development Tools:** `make` for build coordination

### Backend Service
```bash
make backend  # Start FastAPI backend on port 7860
```
- Auto-reloads on file changes
- Health check: http://localhost:7860/health
- Backend components: `api/base/aiexec/`

---

## 2. Component Development

### Component Structure
```
api/base/aiexec/components/
├── agents/           # Agent components
├── data/            # Data processing components
├── embeddings/      # Embedding components
├── input_output/    # Input/output components
├── models/          # Language model components
├── processing/      # Text processing components
├── prompts/         # Prompt components
├── tools/           # Tool components
└── vectorstores/    # Vector store components
```

### Adding New Components
1. **Location:** Add to appropriate subdirectory under `api/base/aiexec/components/`
2. **Import:** Update `__init__.py` with alphabetical imports:
   ```python
   from .my_component import MyComponent

   __all__ = [
       "ExistingComponent",
       "MyComponent",  # Add alphabetically
   ]
   ```
3. **Auto-restart:** Backend auto-restarts on save
4. **Browser refresh:** Refresh browser to see component changes

### Component Testing
- **Unit Tests:** `api/tests/unit/components/`
- **Test Structure:** Mirror component directory structure
- **Test Base Classes:** Use `ComponentTestBaseWithClient` or `ComponentTestBaseWithoutClient`
- **Version Testing:** Provide `file_names_mapping` for backward compatibility

### Development Tips
- **Fast iteration:** Edit component in UI first, then save to source
- **Component updates:** Old components show "Updates Available" after backend restart
- **Testing:** Create comprehensive unit tests for all new components

---

## 3. Backend Code Quality

### Formatting (CRITICAL)
```bash
make format_backend  # Format Python code
```
**Important:** Run `make format_backend` _early and often_ (ideally before running linting or committing changes). It auto-corrects the majority of style issues, preventing lengthy manual fixes when lint errors surface later.

### Linting
```bash
make lint  # Run linting checks
```

### Testing
```bash
make unit_tests  # Run backend unit tests
```

### Pre-commit Workflow
1. **Run `make format_backend`** (FIRST - saves time on lint fixes)
2. Run `make lint`
3. Run `make unit_tests`
4. Commit changes

---

## 4. FastAPI Development

### API Structure
```
api/base/aiexec/api/
├── v1/              # API version 1
│   ├── chat.py      # Chat endpoints
│   ├── flows.py     # Flow management
│   ├── users.py     # User management
│   └── ...
└── v2/              # API version 2 (future)
```

### Testing APIs
- Use `client` fixture from `conftest.py`
- Test with `logged_in_headers` for authenticated endpoints
- Example:
  ```python
  async def test_flows_endpoint(client, logged_in_headers):
      response = await client.post(
          "api/v1/flows/",
          json=flow_data,
          headers=logged_in_headers
      )
      assert response.status_code == 201
  ```

---

## 5. Database Development

### Models Location
```
api/base/aiexec/services/database/models/
├── api_key/         # API key models
├── flow/            # Flow models
├── folder/          # Folder models
├── user/            # User models
└── ...
```

### Database Testing
- Use in-memory SQLite for tests
- Database tests may fail in batch runs - run individually if needed:
  ```bash
  uv run pytest api/tests/unit/test_database.py
  ```

---

## 6. Error Handling Patterns

### Standard Error Responses
```python
from fastapi import HTTPException
from pydantic import BaseModel

class ErrorResponse(BaseModel):
    detail: str
    error_code: str
    context: dict = {}

def raise_http_error(status_code: int, detail: str, error_code: str, **kwargs):
    """Raise standardized HTTP exceptions with error codes."""
    raise HTTPException(
        status_code=status_code,
        detail={
            "detail": detail,
            "error_code": error_code,
            **kwargs
        }
    )

# Usage in endpoints
raise_http_error(
    status_code=404,
    detail="Resource not found",
    error_code="RESOURCE_NOT_FOUND",
    resource_type="user",
    resource_id=user_id
)
```

### Retry Mechanisms
```python
from tenacity import retry, stop_after_attempt, wait_exponential

@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=4, max=10),
    reraise=True
)
async def fetch_external_data(url: str):
    """Fetch data with exponential backoff retry."""
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
        response.raise_for_status()
        return response.json()
```

### Context Managers for Resources
```python
from contextlib import asynccontextmanager

@asynccontextmanager
async def acquire_db_connection():
    """Context manager for database connections with error handling."""
    conn = None
    try:
        conn = await database.acquire_connection()
        yield conn
    except DatabaseError as e:
        logger.error(f"Database error: {str(e)}")
        raise_http_error(500, "Database operation failed", "DATABASE_ERROR")
    finally:
        if conn:
            await conn.close()

# Usage
async with acquire_db_connection() as conn:
    result = await conn.execute(query)
```

### Validation Error Handling
```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from pydantic import ValidationError

app = FastAPI()

@app.exception_handler(ValidationError)
async def validation_exception_handler(request: Request, exc: ValidationError):
    """Handle Pydantic validation errors."""
    errors = []
    for error in exc.errors():
        errors.append({
            "loc": ".".join(str(loc) for loc in error["loc"]),
            "msg": error["msg"],
            "type": error["type"]
        })
    return JSONResponse(
        status_code=422,
        content={
            "detail": "Validation error",
            "error_code": "VALIDATION_ERROR",
            "errors": errors
        }
    )
```

## 7. Async Development Patterns

### Component Async Methods
```python
async def run(self) -> MessageType:
    """Main component execution method."""
    # Use await for async operations
    result = await self.async_operation()
    return result

async def message_response(self) -> Message:
    """Return a Message object for chat components."""
    return Message(
        text=self.input_value,
        sender=self.sender,
        session_id=self.session_id,
    )
```

### Background Tasks
```python
import asyncio

async def process_in_background(self):
    """Process items without blocking."""
    # Use asyncio.create_task for background work
    task = asyncio.create_task(self.heavy_operation())

    # Ensure proper cleanup
    try:
        result = await task
        return result
    except asyncio.CancelledError:
        # Handle cancellation gracefully
        await self.cleanup()
        raise
```

### Queue Operations
```python
async def queue_processing(self):
    """Non-blocking queue operations."""
    queue = asyncio.Queue()

    # Non-blocking put
    queue.put_nowait(data)

    # Timeout-controlled get
    try:
        result = await asyncio.wait_for(queue.get(), timeout=5.0)
        return result
    except asyncio.TimeoutError:
        # Handle timeout appropriately
        raise ComponentError("Processing timeout")
```

---

## 7. Component Integration Testing

### Flow Testing
```python
from tests.unit.build_utils import create_flow, build_flow, get_build_events

async def test_component_in_flow(client, json_flow, logged_in_headers):
    """Test component within a complete flow."""
    flow_id = await create_flow(client, json_flow, logged_in_headers)
    build_response = await build_flow(client, flow_id, logged_in_headers)

    # Validate flow execution
    job_id = build_response["job_id"]
    events_response = await get_build_events(client, job_id, logged_in_headers)
    assert events_response.status_code == 200
```

### External API Testing
```python
@pytest.mark.api_key_required
@pytest.mark.no_blockbuster
async def test_with_real_api(self):
    """Test component with external service."""
    api_key = os.getenv("OPENAI_API_KEY")
    component = MyComponent(api_key=api_key, model="gpt-4o")

    response = await component.run()
    assert response is not None
```

---

## 8. Known Backend Issues

### Testing Quirks
- `test_database.py` may fail in batch runs but pass individually
- Use `@pytest.mark.no_blockbuster` to skip blockbuster plugin when needed
- Context variables may not propagate correctly in `asyncio.to_thread` - test both patterns

### File Changes
- Starter project files auto-format after `aiexec run`
- These formatting changes can be committed or ignored

---

## Backend Development Checklist
- [ ] Component added to appropriate subdirectory
- [ ] `__init__.py` updated with alphabetical imports
- [ ] Code formatted with `make format_backend` (FIRST)
- [ ] Linting passed with `make lint`
- [ ] Unit tests created and passing with `make unit_tests`
- [ ] Component tested in UI with backend restart + browser refresh
- [ ] Version mapping provided for backward compatibility
- [ ] Async patterns implemented correctly with proper cleanup
- [ ] External API calls use appropriate pytest markers
